<!DOCTYPE html><html lang="en"><head><title>index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="index"><meta name="groc-project-path" content="README.md"><meta name="groc-github-url" content="https://github.com/Raynos/ncore"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Raynos/ncore/blob/master/README.md">README.md</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><h1>nCore <a href="http://travis-ci.org/Raynos/ncore"><img src="https://secure.travis-ci.org/Raynos/ncore.png" alt="Build Status" title="" /></a></h1>

<p>A Core library for your node application infrastructure. Handles initialization, bootstrapping and dependency injection for you.</p>

<h2>Status: Rewrite in progress</h2>

<ul>
<li><a href="https://github.com/Raynos/ncore#example">example</a></li>
<li><a href="https://github.com/Raynos/ncore#motivation">motivation</a></li>
<li><a href="https://github.com/Raynos/ncore#docs">docs</a></li>
<li><a href="https://github.com/Raynos/ncore#install">Installation</a></li>
<li><a href="https://github.com/Raynos/ncore#test">test</a></li>
<li><a href="https://github.com/Raynos/ncore#contributors">contributors</a></li>
<li><a href="https://github.com/Raynos/ncore#licence">licence</a></li>
</ul>

<h2><a name="example" href="#example">Example <small><sup>link</sup></small></a></h2>

<p>``` javascript<br />var Core = Object.create(require("nCore")).constructor({<br />        server: {<br />            controller: "hello-world"<br />        }<br />    }),<br />    http = require("http");</p>

<p>Core.use("hello-world", {<br />    define: function (interface) {<br />        interface.print = function (req, res) {<br />            res.end("hello world");<br />        };<br />    }<br />})</p>

<p>Core.use("server", {<br />    inject: function (deps) {<br />        http.createServer(function (req, res) {<br />            deps.controller.print(req, res);<br />        }).listen(8080);<br />    }<br />});</p>

<p>Core.init();<br />```</p>

<h2><a name="motivation" href="#motivation">Motivation <small><sup>link</sup></small></a></h2>

<p>nCore is a dependency injection framework.</p>

<ul>
<li>It strictly defines what a unit is and makes it easy to mock out that unit's dependencies. This makes testing and TDD easy</li>
<li>It injects dependencies into your modules based on a file based configuration system and allows you to define the public interface of a module either using methods or using event emitters. This allows for loose coupling and encapsulation.</li>
<li>It has support for hot reloading of modules. This basically means removing and adding modules on the fly whilst your core is still running</li>
</ul>

<h2><a name="docs" href="#docs">Documentation <small><sup>link</sup></small></a></h2>

<ul>
<li><a href="https://github.com/Raynos/ncore/tree/0.x">nCore 0.x documentation</a>    </li>
<li><a href="https://github.com/Raynos/ncore#module">Module format</a>
<ul><li><a href="https://github.com/Raynos/ncore#define">define</a></li>
<li><a href="https://github.com/Raynos/ncore#inject">inject</a></li>
<li><a href="https://github.com/Raynos/ncore#expose">expose</a></li>
<li><a href="https://github.com/Raynos/ncore#module.init">init</a></li></ul></li>
<li><a href="https://github.com/Raynos/ncore#core">Core</a>
<ul><li><a href="https://github.com/Raynos/ncore#interfaces">Core.interfaces</a></li>
<li><a href="https://github.com/Raynos/ncore#constructor">Core.constructor</a></li>
<li><a href="https://github.com/Raynos/ncore#use">Core.use</a></li>
<li><a href="https://github.com/Raynos/ncore#init">Core.init</a></li>
<li><a href="https://github.com/Raynos/ncore#remove">Core.remove</a></li>
<li><a href="https://github.com/Raynos/ncore#purge">Core.purge</a></li></ul></li>
</ul>

<h2><a name="module" href="#module">Module format <small><sup>link</sup></small></a></h2>

<p>A module has a few public properties that are used by the Core.</p>

<p>A module defines it's own public interface through <a href="https://github.com/Raynos/ncore#define"><code>define</code></a> and accepts it's dependencies through <a href="https://github.com/Raynos/ncore#inject"><code>inject</code></a>. Alternatively a module can define it's dependencies through <a href="https://github.com/Raynos/ncore#expose"><code>expose</code></a> and alternatively if the module has no <a href="https://github.com/Raynos/ncore#inject"><code>inject</code></a> method the dependencies are mixed into the module. </p>

<p>A module also has an <a href="https://github.com/Raynos/ncore#module.init"><code>init</code></a> method which is invoked when the core is done initializing.</p>

<p>Modules are handled in three step phases, </p>

<ol>
<li>First is the <a href="https://github.com/Raynos/ncore#define"><code>define</code></a> phase where every module that is used defines it's public interface. Define is called once a module is used on the core</li>
<li>Second is the <a href="https://github.com/Raynos/ncore#inject"><code>inject</code></a> phase where every module has it's dependencies injected into it. This phase is started when the someone invokes init on the core. In the inject phase modules can do asynchronous startup like opening database connections or asynchronously loading config data from files.</li>
<li>Lastly is the <a href="https://github.com/Raynos/ncore#module.init"><code>init</code></a> phase, this happens after every module says it's done injecting. This also happens after the callback on <a href="https://github.com/Raynos/ncore#init"><code>Core.init</code></a>. This phase is meant to start your application like starting your HTTP server.</li>
</ol>

<h3><a name="define" href="#define"><code>module.define(interface)</code> <small><sup>link</sup></small></a></h3>

<p>A module is the implementation of an interface. When other modules want to interact with it, they should interact through a public interface. The way to define the public interface of a module is by defining an interface.</p>

<p>Note that the public interface passed to other modules and exposed as <a href="https://github.com/Raynos/ncore#interfaces"><code>Core.interfaces</code></a> is actually a proxy of the interface created through define. This means that it has all the same properties and it's methods are thin wrappers that call the real interface. This allows for the interface to change at run-time without other modules having references to dead interfaces. This is needed for hot reloading.</p>

<p>The core invokes define when the module is used</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert")</p>

<p>Core.use("name", {<br />    // define an interface<br />    define: function (interface) {<br />        interface.method = function () {<br />            ...<br />        }<br />    }<br />})</p>

<p>assert(Core.interfaces.name.method)<br />```</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    pd = require("pd"),<br />    assert = require("assert");</p>

<p>Core.use("name", {<br />    define: function (interface) {<br />        pd.extend(interface, {<br />            method: this.method,<br />            public: this.public,<br />            otherMethod: this.otherMethod<br />        })<br />    },<br />    method: function () {<br />        // this is the module<br />        this.counter++;<br />    },<br />    otherMethod: function () {<br />        return this._getCounter();<br />    },<br />    _getCounter: function () {<br />        return this.counter;<br />    },<br />    public: function () {<br />        this.private();<br />    },<br />    private: function () {<br />        this.emit("foobar");<br />    }<br />})</p>

<p>var name = Core.interfaces.name;<br />name.method();<br />assert.equal(name.otherMethod(), 1);<br />name.on("foobar", function () {<br />    assert(true);<br />})<br />name.public();<br />assert(!name.private);<br />```</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert")</p>

<p>Core.use("name", {<br />    define: {<br />        method: function () {<br />            // this is actually the module, not the interface<br />            return this.private()<br />        }<br />    },<br />    private: function () {<br />        return 42;<br />    }<br />})</p>

<p>assert.equal(Core.interfaces.name.method(), 42);<br />```</p>

<h3><a name="inject" href="#inject"><code>module.inject(deps, [done])</code> <small><sup>link</sup></small></a></h3>

<p>A module exposes an inject method which is used to handle the dependencies that are injected. It also has an optional done callback to allow the module to do asynchronous startup procedures.</p>

<p>The core invokes inject when the core is initialized</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor({<br />        foo: {<br />            bar: "bar"<br />        }<br />    }),<br />    assert = require("assert");</p>

<p>Core.use("bar", barObject);</p>

<p>Core.use("foo", {<br />    inject: function (deps) {<br />        // deps.bar is the "bar" interface<br />        assert.equal(deps.bar, Core.interfaces.bar);<br />    }<br />})</p>

<p>Core.init()<br />```</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert");</p>

<p>Core.use("foo", {<br />    inject: function (_, done) {<br />        // Do asynchronous startup<br />        initializeDatabase(configSettings, done);<br />    }<br />})</p>

<p>Core.init(function () {<br />    // all modules are done<br />    doStuff();<br />})<br />```</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor({<br />        foo: {<br />            bar: "bar"<br />        }<br />    }),<br />    assert = require("assert")</p>

<p>Core.use("bar", barObject);</p>

<p>Core.use("foo", {<br />    // if a module has no inject method<br />    // then dependencies are mixed into the module<br />    init: function() {<br />        assert(this.bar);<br />    }<br />})</p>

<p>Core.init()<br />```</p>

<h3><a name="expose" href="#expose"><code>module.expose</code> <small><sup>link</sup></small></a></h3>

<p>Instead of defining an interface you can say what parts of the module should be exposed. Expose should contain an array containing the propertyNames that should become part of the interface</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert")</p>

<p>Core.use("name", {<br />    public: function () {<br />        this.private();<br />    },<br />    private: function () {<br />        // this is also an event emitter<br />        this.emit("somethingHappened");<br />    },<br />    expose: ["public"]<br />})</p>

<p>Core.interfaces.name.on("somethingHappened", function () {<br />    assert(true);<br />})<br />Core.interfaces.name.public();<br />assert(!Core.interfaces.name.private)<br />```</p>

<h3><a name="module.init" href="#module.init"><code>module.init()</code> <small><sup>link</sup></small</a></h3>

<p>A module exposes an init method which is invoked when the core is done initializing.</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert")</p>

<p>Core.use("name", {<br />    inject: function () {<br />        assert("happens first");<br />    },<br />    init: function () {<br />        assert("happens third");<br />    }<br />})</p>

<p>Core.init(function () {<br />    assert("happens second")<br />})<br />```</p>

<h2><a name="core" href="#core"><code>Core</code> <small><sup>link</sup></small></a></h2>

<p>The Core is an object you attach modules to. It keeps a record of the dependency mapping between modules and initializes multiple modules with their correct dependencies.</p>

<h3><a name="interfaces" href="#interfaces"><code>Core.interfaces</code> <small><sup>link</sup></small></a></h3>

<p>The Core has a public property named interfaces that contains all the public interfaces attached to the core.</p>

<p>A public interface is a proxy of the internal interface (the one passed to define) which means it has all the same properties / methods, it just has a thin proxy that invokes them indirectly. This proxy exist for easy module hot reloading.</p>

<p>``` javascript<br />var Core = Object.create(require("ncore")).constructor(),<br />    assert = require("assert");</p>

<p>Core.use("name", {<br />    define: function (interface) {<br />        interface.method = function () { }<br />    }<br />})</p>

<p>assert(Core.interfaces.name.method);<br />```</p>

<h3><a name="constructor" href="#constructor"><code>Core.constructor(deps, [ee])</code> <small><sup>link</sup></small></a></h3>

<p>Instantiate an instance of the core. You need to pass the dependency mapping to the core so it knows what to inject into what module. You can also optionally pass in EventEmitter prototype which will be mixed into every interface.</p>

<p>``` javascript<br />var ncore = require("ncore");</p>

<p>// create an instance<br />var Core = Object.create(ncore).constructor();</p>

<p>Core.use(...);<br />```</p>

<p>``` javascript<br />var ncore = require("ncore"),<br />    assert = require("assert");</p>

<p>var Core = Object.create(ncore).constructor({<br />    // The dependencies for foo are<br />    foo: {<br />        // an object called bar that contains the interface baz<br />        bar: "baz"<br />    }<br />});</p>

<p>Core.use("baz", bazObject);</p>

<p>Core.use("foo", {<br />    inject: function (deps) {<br />        // For module foo the deps object contains a bar property<br />        // that is the interface of bazObject<br />        assert.equal(deps.bar, Core.interfaces.bar);<br />    }<br />});</p>

<p>Core.init()<br />```</p>

<p>``` javascript<br />var ncore = require("ncore");</p>

<p>// constructor also accepts strings as arguments<br />var Core = Object.create(ncore).constructor(require("./dependency.json"));<br />```</p>

<p>``` javascript<br />var ncore = require("ncore"),<br />    EventEmitter = require("eventemitter2").EventEmitter.prototype;</p>

<p>var Core = Object.create(ncore).constructor(null, EventEmitter);</p>

<p>Core.use("bar", {});</p>

<p>Core.init()</p>

<p>// The bar interface is now an EventEmitter2 instance<br />assert(Core.interfaces.bar.many)<br />```</p>

<p>/* TODO */</p>

<h2>Installation <a name="install" href="#install"><small><sup>link</sup></small></a></h2>

<p><code>$ npm install ncore</code></p>

<h2>Test <a name="test" href="#test"><small><sup>link</sup></small></a></h2>

<p><code>$ make test</code></p>

<h2>contributors <a name="contributors" href="#contributors"><small><sup>link</sup></small></a></h2>

<ul>
<li>Raynos</li>
</ul>

<h2>MIT Licenced <a name="licence" href="#licence"><small><sup>link</sup></small></a></h2></div></div></div></div></body></html>