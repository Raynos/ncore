<!DOCTYPE html><html lang="en"><head><title>core</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="core"><meta name="groc-project-path" content="lib/core.js"><meta name="groc-github-url" content="https://github.com/Raynos/ncore"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/Raynos/ncore/blob/master/lib/core.js">lib/core.js</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><pre><code>Modules have three phases.

The definition phase:

    When a module is used on the core, the core will ask the module to 
    define it's interface. This can be done by having a method called 
    define which takes the interface as the first argument. 

    Alternatively this can be done by having a property define which is
    an object that is the interface

    Alternatively this can be done by having a property expose which is
    an array of propertyNames. Those propertyNames are to be taken from
    the module and put into the interface

The injection phase:

    When the core is initialized all the dependencies are injected into
    all the modules. This injection is based on the dependency mapping
    passed into the core when it's constructed

    A module should have an inject method which accepts the 
    dependencies for the module as the first argument. The inject method 
    also get's an optional done callback as the second argument. This is
    used to tell the core that the module is done doing any asynchronous
    startup logic.

    If the module doesn't have an inject method then the dependencies
    are mixed into the module

The init phase:

    After all the dependencies are injected into all the modules, the core
    is ready. Then the init method is invoked on modules that have it.

    The init method is used to start your application, i.e. create your 
    HTTP server or start your cron jobs, etc.

Modules expose a public interface, which is a proxy of the interface
that the module defines. This proxy is just a thin wrapper that indireclty
invokes the interfaces methods. This proxy is used to enable hot code
reload without having to get rid of references to dead objects.

Note that inside the interfaces methods the thisContext value is the module
itself.
</code></pre></div></div><div class="code"><div class="wrapper"><span class="kd">var</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;eventemitter-light&quot;</span><span class="p">),</span>
    <span class="nx">pd</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s2">&quot;pd&quot;</span><span class="p">);</span>

<span class="o">*</span><span class="err">/</span>
<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/*</span>
<span class="cm">        Construct a Core with dependencies and an optional EventEmitter </span>
<span class="cm">        prototype. </span>

<span class="cm">        The dependencies contain the dependency mapping setup for</span>
<span class="cm">        modules, so the core knows what dependencies to inject into what</span>
<span class="cm">        modules. </span>

<span class="cm">        The eventemitter prototype is used to choose the eventEmitter </span>
<span class="cm">        implementation that interfaces have.</span>

<span class="cm">        @param {Object} dependencies - This is a map of dependencies.</span>
<span class="cm">            {</span>
<span class="cm">                &lt;ModuleName&gt;: {</span>
<span class="cm">                    &lt;PropertyName&gt;: &lt;OtherModuleName&gt;</span>
<span class="cm">                }</span>
<span class="cm">            }</span>

<span class="cm">            This means that &lt;ModuleName&gt; will have a deps object injected with</span>
<span class="cm">                a property &lt;PropertyName&gt; which contains the public interface</span>
<span class="cm">                of &lt;OtherModuleName&gt;</span>

<span class="cm">        @param {Object} ee - An optional EventEmitter prototype. Used if you </span>
<span class="cm">            want the interface to inherit from a different EventEmitter then</span>
<span class="cm">            eventemitter-light</span>
<span class="cm">    */</span>
    <span class="nx">constructor</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">constructor</span><span class="p">(</span><span class="nx">dependencies</span><span class="p">,</span> <span class="nx">ee</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">interfaces</span>  <span class="o">=</span> <span class="p">{};</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">_ee</span> <span class="o">=</span> <span class="nx">ee</span> <span class="o">||</span> <span class="nx">EventEmitter</span><span class="p">;</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">_interfaces</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">dependencies</span> <span class="o">===</span> <span class="s2">&quot;string&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">dependencies</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span> <span class="o">=</span> <span class="nx">dependencies</span> <span class="o">||</span> <span class="p">{};</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">that</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="cm">/*</span>
<span class="cm">        This is used to attach a module to the core. When a module is attached</span>
<span class="cm">        the core asks the module to define it&#39;s interface.</span>
<span class="cm">        </span>
<span class="cm">        @param {String} name - The name of this module</span>

<span class="cm">        @param {Object} module - The implementation of the module. </span>
<span class="cm">    */</span>
    <span class="nx">use</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">use</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="kr">interface</span> <span class="o">=</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">extend</span><span class="p">({},</span> <span class="k">this</span><span class="p">.</span><span class="nx">_ee</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">module</span><span class="p">.</span><span class="nx">define</span> <span class="o">===</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">module</span><span class="p">.</span><span class="nx">define</span><span class="p">(</span><span class="kr">interface</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">define</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">pd</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="kr">interface</span><span class="p">,</span> <span class="nx">module</span><span class="p">.</span><span class="nx">define</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">expose</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">module</span><span class="p">.</span><span class="nx">expose</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">addToInterface</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">_makeProxy</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="kr">interface</span><span class="p">,</span> <span class="nx">module</span><span class="p">);</span>

        <span class="kd">function</span> <span class="nx">addToInterface</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">interface</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">module</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="cm">/*</span>
<span class="cm">        </span>
<span class="cm">    */</span>
    <span class="nx">init</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">init</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
            <span class="nx">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">_interfaces</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">invokeInject</span><span class="p">);</span>
        <span class="nx">next</span><span class="p">();</span>

        <span class="kd">function</span> <span class="nx">invokeInject</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">[</span><span class="nx">name</span><span class="p">],</span>
                <span class="nx">deps</span> <span class="o">=</span> <span class="p">{};</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="p">{</span>
                <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">name</span><span class="p">]).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">mapToInterface</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">inject</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">module</span><span class="p">.</span><span class="nx">inject</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span>  <span class="p">{</span>
                    <span class="nx">counter</span><span class="o">++</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="nx">module</span><span class="p">.</span><span class="nx">inject</span><span class="p">(</span><span class="nx">deps</span><span class="p">,</span> <span class="nx">next</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">pd</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">module</span><span class="p">,</span> <span class="nx">deps</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="kd">function</span> <span class="nx">mapToInterface</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">var</span> <span class="nx">dependency</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">dependencies</span><span class="p">[</span><span class="nx">name</span><span class="p">][</span><span class="nx">key</span><span class="p">];</span>
                <span class="nx">deps</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">interfaces</span><span class="p">[</span><span class="nx">dependency</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="nx">counter</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">callback</span> <span class="o">&amp;&amp;</span> <span class="nx">callback</span><span class="p">();</span>
                <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">invokeInit</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nx">invokeInit</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">module</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
            <span class="nx">module</span><span class="p">.</span><span class="nx">init</span> <span class="o">&amp;&amp;</span> <span class="nx">module</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">remove</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">remove</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">,</span>
            <span class="nx">module</span> <span class="o">=</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>

        <span class="k">delete</span> <span class="nx">that</span><span class="p">.</span><span class="nx">interfaces</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="k">delete</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_interfaces</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
        <span class="k">delete</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>

        <span class="nx">module</span><span class="p">.</span><span class="nx">destroy</span> <span class="o">&amp;&amp;</span> <span class="nx">module</span><span class="p">.</span><span class="nx">destroy</span><span class="p">();</span>
    <span class="p">},</span>
    <span class="nx">purge</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">purge</span><span class="p">()</span> <span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">interfaces</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">callRemove</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
        
        <span class="kd">function</span> <span class="nx">callRemove</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">_makeProxy</span><span class="o">:</span> <span class="kd">function</span> <span class="nx">_makeProxy</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="kr">interface</span><span class="p">,</span> <span class="nx">module</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">proxy</span> <span class="o">=</span> <span class="p">{},</span>
            <span class="nx">that</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>

        <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="kr">interface</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">proxyProperty</span><span class="p">);</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">_interfaces</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="kr">interface</span><span class="p">;</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">_modules</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">module</span><span class="p">;</span>
        <span class="nx">that</span><span class="p">.</span><span class="nx">interfaces</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">proxy</span><span class="p">;</span>

        <span class="kd">function</span> <span class="nx">proxyProperty</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="kr">interface</span><span class="p">[</span><span class="nx">name</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">value</span> <span class="o">===</span> <span class="s2">&quot;function&quot;</span><span class="p">)</span> <span class="p">{</span>
                <span class="kr">interface</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">module</span><span class="p">);</span>
                <span class="nx">proxy</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">proxyFunction</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">proxy</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="kd">function</span> <span class="nx">proxyFunction</span><span class="p">(</span><span class="nx">functionName</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">proxy</span><span class="p">;</span>

            <span class="kd">function</span> <span class="nx">proxy</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">that</span><span class="p">.</span><span class="nx">_interfaces</span><span class="p">[</span><span class="nx">name</span><span class="p">][</span><span class="nx">functionName</span><span class="p">]</span>
                    <span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span></div></div></div></div></body></html>